# PPDB åŒæ­¥æœºåˆ¶è®¾è®¡

## 1. æ¦‚è¿°

### 1.1 è®¾è®¡ç›®æ ‡
- é«˜æ€§èƒ½å¹¶å‘è®¿é—®
- æœ€å°åŒ–é”ç«äº?
- ä¿è¯æ•°æ®ä¸€è‡´æ€?
- æ”¯æŒæ— é”æ“ä½œ

### 1.2 å…³é”®ç‰¹æ€?
- ç»†ç²’åº¦é”æ§åˆ¶
- åŸå­æ“ä½œæ”¯æŒ
- æ— é”æ•°æ®ç»“æ„
- å¹¶å‘æ§åˆ¶æœºåˆ¶

## 2. åŒæ­¥åŸè¯­

### 2.1 åŸºç¡€åŒæ­¥ç±»å‹
- äº’æ–¥é”?(Mutex)
- è¯»å†™é”?(RWLock)
- è‡ªæ—‹é”?(Spinlock)
- æ¡ä»¶å˜é‡ (Condition)

### 2.2 åŸå­æ“ä½œ
- CAS (Compare And Swap)
- FAA (Fetch And Add)
- Memory Barrier
- Memory Ordering

## 3. æ— é”å®ç°

### 3.1 æ— é”æ•°æ®ç»“æ„
- æ— é”é˜Ÿåˆ—
- æ— é”æ ?
- æ— é”å“ˆå¸Œè¡?
- æ— é”è·³è¡¨

### 3.2 å®ç°æŠ€æœ?
- å†…å­˜å±éšœ
- åŸå­æŒ‡ä»¤
- ABAé—®é¢˜å¤„ç†
- å†…å­˜å›æ”¶

### 3.3 æ€§èƒ½è€ƒè™‘
- Cacheä¸€è‡´æ€?
- False Sharing
- å†…å­˜å¯¹é½
- æŒ‡ä»¤é‡æ’

## 4. å¹¶å‘æ§åˆ¶

### 4.1 é”ç­–ç•?
- åˆ†æ®µé”?
- æ„å‘é”?
- ä¹è§‚é”?
- æ‚²è§‚é”?

### 4.2 æ­»é”é¢„é˜²
- é”é¡ºåº?
- è¶…æ—¶æœºåˆ¶
- æ­»é”æ£€æµ?
- èµ„æºæ’åº

### 4.3 æ€§èƒ½ä¼˜åŒ–
- é”ç²’åº?
- é”ç«äº?
- é”å‡çº?
- é”é™çº?

## 5. åŒæ­¥æ¨¡å¼

### 5.1 è¯»å†™æ¨¡å¼
- å¤šè¯»å•å†™
- å†™æ—¶å¤åˆ¶
- å¿«ç…§éš”ç¦»
- MVCC

### 5.2 å¹¶å‘æ¨¡å¼
- ç”Ÿäº§è€…æ¶ˆè´¹è€?
- è¯»å†™è€…é—®é¢?
- å“²å­¦å®¶å°±é¤?
- å±éšœåŒæ­¥

## 6. å®ç°ç»†èŠ‚

### 6.1 å…³é”®æ•°æ®ç»“æ„
```c
typedef struct {
    atomic_int ref_count;
    void *data;
} shared_object_t;

typedef struct {
    atomic_flag lock;
    int writer_count;
    int reader_count;
} rw_lock_t;
```

### 6.2 æ ¸å¿ƒæ“ä½œ
```c
// åŸå­å¢åŠ å¼•ç”¨è®¡æ•°
int ref_inc(shared_object_t *obj) {
    return atomic_fetch_add(&obj->ref_count, 1);
}

// åŸå­å‡å°‘å¼•ç”¨è®¡æ•°
int ref_dec(shared_object_t *obj) {
    return atomic_fetch_sub(&obj->ref_count, 1);
}

// æ— é”CASæ“ä½œ
bool cas_update(atomic_int *target, int expected, int desired) {
    return atomic_compare_exchange_strong(target, &expected, desired);
}
```

## 7. æµ‹è¯•éªŒè¯

### 7.1 å•å…ƒæµ‹è¯•
- åŸºæœ¬åŠŸèƒ½æµ‹è¯•
- è¾¹ç•Œæ¡ä»¶æµ‹è¯•
- å‹åŠ›æµ‹è¯•
- å¹¶å‘æµ‹è¯•

### 7.2 æ€§èƒ½æµ‹è¯•
- ååé‡æµ‹è¯?
- å»¶è¿Ÿæµ‹è¯•
- ç«äº‰æµ‹è¯•
- æ‰©å±•æ€§æµ‹è¯?

### 7.3 æ­£ç¡®æ€§éªŒè¯?
- æ­»é”æ£€æµ?
- æ•°æ®ä¸€è‡´æ€?
- å†…å­˜æ³„æ¼
- ç«æ€æ¡ä»?