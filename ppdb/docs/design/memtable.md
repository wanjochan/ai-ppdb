# MemTable 设计文档

## 系统角色
MemTable 是 PPDB 中的核心组件之一，在整个系统中扮演着关键角色：

### 功能定位
1. 写入缓冲区
   - 接收所有新的写入操作（插入/更新/删除）
   - 将随机写入转换为顺序写入
   - 批量刷盘以提高写入性能

2. 读取加速层
   - 缓存最新写入的数据
   - 提供快速的内存查询
   - 减少磁盘访问次数

### 系统架构
1. LSM-Tree 组件
   - 作为 LSM-Tree 的内存部分
   - 与 WAL 配合保证数据可靠性
   - 与 SSTable 配合实现数据持久化

2. 写入流程
   ```
   Client Write -> WAL -> MemTable(活跃) -> 
   当 MemTable 满时：
   MemTable(活跃) -> MemTable(只读) -> SSTable(磁盘)
   ```

3. 读取流程
   ```
   Client Read -> MemTable(活跃) -> 
                 MemTable(只读) -> 
                 SSTable Level 0 -> 
                 SSTable Level 1 -> 
                 ...
   ```

### 状态转换
1. 活跃状态
   - 接受写入和读取操作
   - 跟踪内存使用情况
   - 检查是否需要刷盘

2. 只读状态
   - 不再接受新的写入
   - 继续服务读取请求
   - 等待刷盘完成

3. 刷盘过程
   - 将数据序列化为 SSTable 格式
   - 顺序写入磁盘文件
   - 更新元数据信息

## 设计目标
1. 高性能：支持快速的读写操作
2. 内存安全：严格控制内存使用
3. 并发安全：支持多线程访问
4. 可靠性：保证数据的正确性和一致性
5. 通用性：支持多种数据格式和编码

## 数据限制

### 数据格式支持
1. 键值类型
   - 使用 uint8_t* 类型存储二进制数据
   - 完全支持 UTF-8 编码字符串
   - 支持任意二进制数据格式
   - 不对数据内容做任何假设或限制

2. 编码处理
   - 不进行编码转换
   - 按字节比较进行排序
   - UTF-8 字符串自然排序（因为 UTF-8 编码的字典序与字符序相同）

### 大小限制
1. 键（Key）限制
   - 最小长度：1 字节
   - 建议最大长度：1KB
   - 必须指定准确的长度
   - 不要求 NULL 结尾

2. 值（Value）限制
   - 最小长度：0 字节
   - 建议最大长度：100KB
   - 支持空值（NULL 值）
   - 不要求 NULL 结尾

3. 总量限制
   - 单个键值对大小 = key_len + value_len
   - 实际内存占用还包括跳表节点开销
   - 建议单个 MemTable 条目数不超过 100万
   - 总大小不超过创建时指定的 max_size

4. max_size 参数说明
   - 由用户在创建 MemTable 时指定
   - 建议值范围：
     - 小型场景（1MB 以下）：适合临时存储、缓存等
     - 中型场景（1MB ~ 10MB）：适合一般应用
     - 大型场景（10MB ~ 100MB）：适合数据密集型应用
   - 选择考虑因素：
     - 可用内存大小
     - 预期数据量
     - 写入频率
     - 刷新策略
   - 不建议设置过大的原因：
     - 内存碎片增加
     - 跳表性能下降
     - 并发写入冲突增加
     - 刷盘时间增加

## 架构设计

### 核心组件
1. 跳表（SkipList）
   - 用于存储有序的键值对数据
   - 支持 O(log N) 的查找、插入和删除操作
   - 使用概率平衡来维护层数，最大层数为 12

2. 内存管理
   - 使用 max_size 参数限制总内存使用
   - 使用原子计数器跟踪当前内存使用
   - 在插入操作时检查内存限制

3. 并发控制
   - 使用互斥锁保护关键操作
   - 读操作无锁，写操作需要加锁
   - 使用原子操作更新内存计数

### 数据结构
```c
struct ppdb_memtable_t {
    ppdb_skiplist_t* list;      // 跳表实现
    size_t max_size;            // 最大大小
    atomic_size_t current_size; // 当前大小
    pthread_mutex_t mutex;      // 并发控制
};
```

## 实现细节

### 内存管理策略
1. 内存分配
   - 键值对数据使用动态内存分配
   - 跳表节点使用柔性数组优化内存布局
   - 失败时确保正确释放已分配的内存

2. 大小计算
   - 键值对大小 = 键长度 + 值长度
   - 不包括内部数据结构开销
   - 使用原子操作确保计数准确

3. 内存限制
   - 插入前检查总大小
   - 超过限制时返回错误
   - 定期检查是否需要刷新到磁盘

### 并发控制机制
1. 互斥锁
   - 保护写操作（插入、删除、更新）
   - 保护内部数据结构修改
   - 最小化锁的持有时间

2. 原子操作
   - 用于更新内存使用计数
   - 避免竞态条件
   - 提供一致的内存视图

3. 迭代器安全
   - 迭代器操作不需要加锁
   - 但可能看到过期的数据
   - 用户需要自己处理一致性

## 性能优化

### 关键优化点
1. 跳表优化
   - 使用概率平衡减少维护开销
   - 优化节点内存布局
   - 缓存友好的数据访问模式

2. 锁优化
   - 最小化锁的粒度
   - 减少锁的持有时间
   - 避免不必要的锁竞争

3. 内存优化
   - 内联小键值对
   - 重用内存块
   - 批量内存分配

### 性能数据
1. 时间复杂度
   - 查找：O(log N)
   - 插入：O(log N)
   - 删除：O(log N)
   - 迭代：O(1) per step

2. 空间复杂度
   - 跳表：O(N)
   - 每个节点额外开销：O(1)
   - 最大层数：12

## 测试策略

### 测试类型
1. 基本测试
   - 创建/销毁
   - 基本的 CRUD 操作
   - 边界条件检查

2. 边界测试
   - 空键/空值
   - 大键/大值
   - 内存限制

3. 并发测试
   - 多线程读写
   - 并发更新同一键
   - 压力测试

4. 迭代器测试
   - 基本迭代
   - Seek 操作
   - 空表迭代

### 测试覆盖
1. 功能覆盖
   - 所有 API 函数
   - 所有错误路径
   - 边界条件

2. 代码覆盖
   - 语句覆盖
   - 分支覆盖
   - 条件覆盖

## 注意事项

### 使用限制
1. 内存限制
   - 单个键值对不应过大
   - 总大小不超过设定值
   - 及时处理刷新信号

2. 并发限制
   - 写操作可能阻塞
   - 迭代器可能看到旧数据
   - 不支持事务操作

### 最佳实践
1. 内存管理
   - 合理设置大小限制
   - 监控内存使用
   - 及时刷新到磁盘

2. 并发处理
   - 最小化锁的持有时间
   - 避免长时间的写操作
   - 注意迭代器的一致性

3. 错误处理
   - 检查所有返回值
   - 正确处理内存不足
   - 优雅处理并发冲突

## 未来改进

### 待优化点
1. 性能优化
   - 实现细粒度锁
   - 优化内存分配策略
   - 引入布隆过滤器

2. 功能增强
   - 支持事务操作
   - 添加范围删除
   - 提供更多统计信息

3. 可用性改进
   - 提供更多调试信息
   - 改进错误处理
   - 增加监控接口 

## 高强度环境风险分析

### 潜在风险点
1. 内存溢出风险
   - 写入速度远大于刷盘速度时可能耗尽系统内存
   - 多个只读 MemTable 等待刷盘会占用大量内存
   - 系统 OOM 可能导致进程崩溃

2. 并发瓶颈
   - 写入密集场景下锁竞争严重
   - 单锁设计限制了写入吞吐量
   - 长时间的锁等待可能影响系统响应

3. 刷盘延迟
   - 刷盘速度跟不上写入速度
   - 产生过多的只读 MemTable
   - 磁盘 I/O 可能成为瓶颈

### 当前应对策略
1. 内存控制
   - 严格的 max_size 限制
   - 主动触发刷盘机制
   - 拒绝超出限制的写入

2. 并发优化
   - 读操作无锁设计
   - 最小化锁临界区
   - 批量写入优化

3. 刷盘优化
   - 异步刷盘机制
   - 只读 MemTable 队列
   - 后台合并策略

### 建议的增强措施
1. 内存安全
   - 实现全局内存限制
   - 动态调整 max_size
   - 增加内存预警机制

2. 并发提升
   - 实现分片锁设计
   - 引入无锁数据结构
   - 优化写入路径

3. 刷盘加速
   - 实现并行刷盘
   - 优化文件 I/O
   - 智能调度策略

### 监控指标
1. 内存指标
   - 当前内存使用量
   - MemTable 数量统计
   - 内存使用趋势

2. 性能指标
   - 写入延迟统计
   - 锁竞争情况
   - 操作吞吐量

3. 刷盘指标
   - 刷盘队列长度
   - 刷盘延迟时间
   - I/O 使用情况

### 应急预案
1. 过载保护
   - 触发写入限流
   - 加速刷盘处理
   - 拒绝非关键写入

2. 资源释放
   - 优先刷盘大体积数据
   - 清理过期数据
   - 压缩内存占用

3. 降级策略
   - 只读模式切换
   - 临时扩大限制
   - 请求排队处理 

## 持久性保证

### WAL（Write-Ahead Logging）
1. 基本原理
   - 所有写操作先写入 WAL，再写入 MemTable
   - WAL 保证数据持久性和崩溃恢复
   - 顺序写入提供高性能

2. 文件格式
   ```
   WAL 文件结构：
   [文件头]
   - Magic Number (4字节): "PWAL"
   
   [记录格式]
   - 记录头部
     * 类型 (4字节): PUT/DELETE
     * 键长度 (4字节)
     * 值长度 (4字节)
     * CRC32校验和 (4字节)
   - 键数据
   - 值数据（可选）
   ```

3. 可靠性保证
   - CRC32 校验确保数据完整性
   - 同步写入选项（sync_write）
   - 文件分段管理，避免单个文件过大

4. 性能优化
   - 顺序写入
   - 批量写入缓冲
   - 异步归档清理

### 崩溃恢复
1. 恢复流程
   ```
   1. 创建空 MemTable
   2. 扫描 WAL 目录
   3. 按序号顺序读取 WAL 文件
   4. 验证每条记录的校验和
   5. 重放操作到 MemTable
   ```

2. 错误处理
   - 文件损坏检测
   - 校验和验证
   - 部分恢复支持

3. 性能考虑
   - 并行恢复（待实现）
   - 增量检查点（待实现）
   - 选择性跳过

### 文件管理
1. 文件组织
   ```
   wal/
   ├── wal.0
   ├── wal.1
   ├── wal.2
   └── archive/
       ├── wal.0
       └── wal.1
   ```

2. 生命周期
   - 活跃文件：当前写入
   - 只读文件：等待归档
   - 归档文件：可以删除

3. 维护策略
   - 定期归档
   - 自动清理
   - 空间回收

## 监控和调优

### 监控指标
1. 内存指标
   - 当前使用量
   - 峰值使用
   - 警告次数

2. 性能指标
   - 写入延迟
   - 读取延迟
   - 冲突次数

3. WAL 指标
   - 文件数量
   - 写入速度
   - 恢复时间

### 调优参数
1. MemTable 参数
   - max_size
   - warning_threshold
   - critical_threshold

2. WAL 参数
   - segment_size
   - sync_write
   - buffer_size（待实现）

### 性能优化
1. 写入优化
   - 批量写入
   - 异步刷盘
   - 压缩编码

2. 读取优化
   - 缓存优化
   - 索引优化
   - 并发优化

3. 恢复优化
   - 并行恢复
   - 增量恢复
   - 选择性跳过

## 最佳实践

### 配置建议
1. MemTable 配置
   ```sql
   小型场景（1GB 以下）：
   - max_size: 64MB
   - warning_threshold: 0.8
   - critical_threshold: 0.9

   中型场景（1GB-10GB）：
   - max_size: 256MB
   - warning_threshold: 0.7
   - critical_threshold: 0.8

   大型场景（10GB 以上）：
   - max_size: 1GB
   - warning_threshold: 0.6
   - critical_threshold: 0.7
   ```

2. WAL 配置
   ```sql
   小型场景：
   - segment_size: 64MB
   - sync_write: true

   中型场景：
   - segment_size: 256MB
   - sync_write: false（需要权衡）

   大型场景：
   - segment_size: 1GB
   - sync_write: false（需要权衡）
   ```

### 运维建议
1. 监控要点
   - 内存使用趋势
   - 写入延迟波动
   - WAL 文件增长

2. 告警设置
   - 内存接近阈值
   - 写入延迟超标
   - 恢复错误

3. 定期维护
   - WAL 归档
   - 性能分析
   - 容量规划

## 性能优化探索

> 注意：以下内容为探索性设计，尚未实现和验证，仅供参考。

### 无锁结构优化

#### 1. 无锁跳表设计
```c
typedef struct {
    uint8_t* key;
    size_t key_len;
    uint8_t* value;
    size_t value_len;
    atomic_ulong version;      // 版本号，用于处理 ABA 问题
    struct skipnode_t* forward[];  // 原子指针数组
} skipnode_t;

typedef struct {
    int level;
    atomic_size_t size;
    skipnode_t* header;
} skiplist_t;
```

关键设计点：
- 使用原子操作替代互斥锁
- 使用 CAS 操作实现无锁插入和删除
- 读操作完全无锁
- 版本号机制避免 ABA 问题

#### 2. MemTable 分片设计
```c
typedef struct {
    size_t shard_count;           // 分片数量
    ppdb_memtable_shard_t* shards;  // 分片数组
    atomic_size_t total_size;     // 总大小
} ppdb_memtable_t;

typedef struct {
    skiplist_t* list;
    pthread_mutex_t mutex;
    size_t size_limit;
    atomic_size_t current_size;
} ppdb_memtable_shard_t;
```

优势：
- 数据按键范围分片
- 每个分片独立加锁
- 减少锁竞争
- 支持分片级别的独立刷盘

#### 3. 内存池优化
```c
typedef struct {
    void* blocks;              // 预分配内存块
    atomic_ptr_t free_list;    // 空闲块链表
    size_t block_size;         // 块大小
    size_t total_blocks;       // 总块数
} memory_pool_t;
```

目标：
- 预分配固定大小内存块
- 使用无锁队列管理
- 减少内存碎片
- 提高分配效率

### 分阶段实施计划

#### 第一阶段
1. 无锁跳表基础框架
2. 基础监控指标

#### 第二阶段
1. MemTable 分片实现
2. 内存池实现

#### 第三阶段
1. 批量操作接口
2. 完善监控系统

### 风险评估

1. 实现复杂度
   - 无锁算法实现难度高
   - 需要严格的并发测试
   - 边界条件处理复杂

2. 性能权衡
   - CAS 操作可能导致 CPU 使用率上升
   - 需要实际负载测试验证收益
   - 内存开销可能增加

3. 可维护性
   - 代码复杂度提高
   - 调试难度增加
   - 需要专门的性能分析工具

### 后续建议

1. 原型验证
   - 先实现简单原型
   - 进行性能基准测试
   - 收集实际数据支撑决策

2. 渐进式改进
   - 分阶段实施
   - 保持向后兼容
   - 灰度发布策略

### 系统层面性能分析

在无锁设计中，性能瓶颈从应用层的锁竞争转移到了操作系统和硬件层面：

#### 1. CPU 缓存一致性
- 多核 CPU 之间的缓存同步（Cache Coherency）成为主要瓶颈
- CAS 操作会触发 CPU 的 MESI 协议
- 频繁的 CAS 可能导致缓存行颠簸（Cache Line Bouncing）

#### 2. 内存屏障
- 原子操作需要内存屏障（Memory Barrier）
- 会阻止 CPU 的指令重排优化
- 强制刷新 Store Buffer 和 Invalidate Queue

#### 3. 系统调度
- 线程在 CAS 失败后的重试会消耗 CPU 时间
- 过多重试可能导致调度器降低线程优先级
- 线程颠簸（Thread Thrashing）问题

#### 优化策略

1. 数据结构优化
   - 使用填充（Padding）避免伪共享
   - 批量 CAS 减少原子操作次数
   - 使用 NUMA 感知的数据分布

2. 算法优化
   - 退避算法（Backoff）减少重试频率
   - 帮助机制（Helping）让等待线程做有用工作
   - 组合原子操作减少内存屏障

3. 系统层面
   - 线程亲和性（Thread Affinity）
   - 使用大页（Huge Pages）减少 TLB 缺失
   - NUMA 绑定优化内存访问

这表明无锁编程实际上是将锁的开销转化为了硬件同步开销，需要在实际场景中权衡取舍。在某些情况下，精心设计的细粒度锁可能比无锁方案更优。