# PPDB 无锁实现设计

> 本文档详细说明了 PPDB 的无锁数据结构设计和实现。它是性能优化的关键组件，负责提供高并发访问能力。相关文档：
> - MemTable 设计见 `design/memtable.md`
> - 整体设计见 `overview/DESIGN.md`
> - 开发规范见 `overview/DEVELOPMENT.md`

## 实现状态
✅ 已完成基本实现
- [x] 统一同步原语 (sync)
  - [x] 互斥锁模式 (基于 pthread_mutex)
  - [x] 自旋锁模式 (基于原子操作)
  - [x] 读写锁模式 (基于 pthread_rwlock)
  - [x] 引用计数管理
- [x] 无锁跳表（atomic_skiplist）
  - [x] 原子操作支持
  - [x] 引用计数内存管理
  - [x] 无锁并发操作
- [x] 分片内存表（sharded_memtable）
  - [x] 基于无锁跳表
  - [x] 分片并发优化
  - [x] 原子计数器

## 1. 设计目标

### 1.1 功能目标
- 提供统一的同步原语接口
- 支持多种同步模式
- 保证线程安全和数据一致性
- 支持高性能的读写操作

### 1.2 性能目标
- 单节点写入性能 > 100K QPS
- 单节点读取性能 > 500K QPS
- P99延迟 < 1ms
- 线性扩展能力

## 2. 核心组件设计

### 2.1 同步原语
同步原语提供三种基本模式：

1. 互斥锁模式 (PPDB_SYNC_MUTEX)
   - 基于 pthread_mutex 实现
   - 适用于普通的互斥场景
   - 支持完整的 POSIX 互斥语义

2. 自旋锁模式 (PPDB_SYNC_SPINLOCK)
   - 基于原子操作实现
   - 适用于短期锁定场景
   - 避免线程切换开销

3. 读写锁模式 (PPDB_SYNC_RWLOCK)
   - 基于 pthread_rwlock 实现
   - 适用于读多写少场景
   - 提供读写分离的并发控制

注意：分片锁不是独立的同步模式，而是在这些基本模式之上的优化策略，用于减少锁竞争。

### 2.2 无锁跳表
- 基于原子操作实现的无锁数据结构
- 支持无锁的插入、删除和查找操作
- 使用引用计数进行内存管理
- 采用延迟删除避免 ABA 问题

### 2.3 分片内存表
分片内存表是在基本同步原语之上的一个优化实现：
- 使用哈希分片减少锁竞争
- 每个分片使用基本同步模式之一
- 分片数量优化为 2 的幂
- 支持动态扩展分片

## 3. 实现细节

### 3.1 内存管理
- 使用引用计数进行内存管理
- 延迟删除避免 ABA 问题
- 原子操作保证线程安全

### 3.2 并发控制
- 统一的同步原语接口
- 基本同步模式的选择
  - 互斥锁：需要严格互斥的场景
  - 自旋锁：短期锁定场景
  - 读写锁：读多写少场景
- 分片策略优化
  - 合理的分片数量
  - 高效的哈希函数
  - 动态分片调整

### 3.3 性能优化
- 分片数量优化为 2 的幂
- 缓存行对齐优化
- 内存布局优化
- 原子操作优化

## 4. 下一步计划
1. 实现无锁 WAL
2. 优化分片策略
3. 添加性能测试
4. 进行压力测试
5. 补充单元测试

## 5. 监控和诊断

### 5.1 性能指标
- 竞争次数统计
- 等待时间统计
- 分片使用率统计

### 5.2 调试支持
- DEBUG 模式下的详细统计
- 节点状态跟踪
- 引用计数监控

## 6. 注意事项

### 6.1 内存屏障
- 确保原子操作的正确性
- 避免编译器和 CPU 重排序
- 正确使用内存序

### 6.2 ABA 问题
- 使用引用计数避免 ABA
- 延迟删除节点
- 标记删除状态

### 6.3 性能调优
- 合理设置分片数量
- 优化自旋参数
- 调整退避策略
