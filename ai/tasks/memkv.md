# MemKV 任务计划

## 问题
- 需要实现一个纯内存的 KV 存储系统
- 需要兼容 Memcached 协议
- 暂不考虑持久化

## 分析

### 核心需求
1. 内存存储
   - 纯内存的 KV 存储结构
   - 高效的读写性能
   - 合理的内存管理策略

2. Memcached 协议兼容
   - 支持基本的 get/set 操作
   - 支持 delete 操作
   - 支持基本的统计信息

3. 网络服务
   - 复用现有的网络框架
   - 支持并发连接
   - 错误处理机制

### 技术方案

1. 代码组织
   - peer 组件：具体业务实现
     - peer_memkv.h：对外接口定义
     - peer_memkv.c：KV存储和Memcached协议实现
   
   - poly 组件：通用功能封装
     - poly_hashtable：通用哈希表实现，可被其他模块复用
     - poly_cmdline：复用现有命令行框架

2. 数据结构设计
   - KV 条目结构
     - key：字符串类型的键
     - value：二进制数据
     - value_size：值大小
     - flags：Memcached flags
     - exptime：过期时间

   - 存储引擎结构
     - hashtable：复用 poly_hashtable
     - stats：基础统计信息
     - config：运行时配置

## 执行计划

### 阶段一：基础框架
1. poly_hashtable 实现
   - 通用哈希表接口设计
   - 基本的 CRUD 操作
   - 支持自定义比较函数
   - 支持遍历操作

2. peer_memkv 基础结构
   - 初始化框架
   - 集成 poly_hashtable
   - 基本的 KV 操作封装

### 阶段二：Memcached 协议
1. 协议解析实现
   - 文本协议解析
   - 命令处理流程
   - 错误处理机制

2. 命令支持
   - get/set 实现
   - delete 实现
   - stats 实现

### 阶段三：完善功能
1. 性能优化
   - 内存管理优化
   - 并发处理优化
   - 过期处理机制

2. 测试验证
   - 单元测试
   - 并发测试
   - 性能测试

## 风险评估
1. 技术风险
   - 哈希表性能
   - 内存管理效率
   - 并发安全性

2. 兼容性风险
   - Memcached 协议兼容性
   - 不同客户端的支持

## 后续规划
1. 功能扩展
   - 更多 Memcached 命令支持
   - 简单持久化机制
   - 集群支持

2. 性能优化
   - 内存池优化
   - 并发优化
   - 网络性能优化

## 代码设计细节

### poly_hashtable 接口设计
1. 数据结构
   - hashtable_t：哈希表结构
     - 存储桶数组
     - 当前元素数量
     - 负载因子阈值
     - 哈希函数指针
     - 比较函数指针
   
2. 核心接口
   - hashtable_create：创建哈希表，支持配置初始大小和自定义函数
   - hashtable_destroy：销毁哈希表，清理所有资源
   - hashtable_insert：插入键值对，处理冲突和自动扩容
   - hashtable_find：查找键对应的值
   - hashtable_delete：删除键值对
   - hashtable_foreach：遍历哈希表的回调接口

3. 辅助功能
   - 自动扩容机制
   - 冲突解决（链地址法）
   - 迭代器支持

### peer_memkv 接口设计
1. 数据结构
   - memkv_t：KV存储主结构
     - hashtable：底层存储（使用 poly_hashtable）
     - stats：统计信息（命中率、总请求数等）
     - config：配置信息（最大内存、过期策略等）
   
   - memkv_item_t：存储项结构
     - key：字符串键
     - value：二进制数据
     - flags：Memcached 标志位
     - exptime：过期时间
     - size：数据大小
     - cas：版本号（可选）

2. 外部接口
   - memkv_init：初始化 KV 存储
   - memkv_shutdown：关闭 KV 存储
   - memkv_process_command：处理 Memcached 命令
   - memkv_get_stats：获取统计信息

3. 内部接口
   - memkv_get：获取键值
   - memkv_set：设置键值
   - memkv_delete：删除键值
   - memkv_expire：过期处理
   - memkv_parse_command：命令解析
   - memkv_format_response：响应格式化

### Memcached 协议实现
1. 文本协议命令
   ```
   get <key>
   set <key> <flags> <exptime> <bytes>
   delete <key>
   stats
   version
   quit
   ```

2. 响应格式
   ```
   VALUE <key> <flags> <bytes>
   <data>
   END

   STORED
   NOT_STORED
   DELETED
   NOT_FOUND
   ERROR
   CLIENT_ERROR
   SERVER_ERROR
   ```

3. 命令处理流程
   - 解析命令行
   - 验证参数
   - 执行操作
   - 格式化响应
   - 发送结果

### 内存管理策略
1. 内存分配
   - 小对象使用内存池
   - 大对象直接分配
   - 对齐处理

2. 过期处理
   - 惰性删除：访问时检查
   - 定期清理：后台任务
   - LRU 策略（可选）

3. 内存限制
   - 最大内存限制
   - 驱逐策略
   - 内存使用统计

### 并发控制
1. 基本策略
   - 读写锁分离
   - 分段锁设计
   - 无锁操作优化

2. 关键点保护
   - 哈希表扩容
   - 统计信息更新
   - 过期处理

### 错误处理
1. 错误类型
   - 系统错误（内存不足、网络错误）
   - 客户端错误（参数错误、格式错误）
   - 操作错误（键不存在、已存在）

2. 错误处理策略
   - 错误码定义
   - 日志记录
   - 客户端响应

### 网络实现设计
1. 整体架构
   - 采用 socket + select + 线程池模式
   - 复用 infra_net 和 infra_sync 基础设施
   - 参考 peer_rinetd 的框架设计

2. 关键结构
   - memkv_context：全局上下文
     - running：运行状态
     - store：KV存储实例
     - listener：监听socket
     - pool：线程池
     - config：配置信息

   - memkv_conn：客户端连接
     - socket：客户端socket
     - buffer：命令缓冲区
     - parse_state：协议解析状态
     - current_cmd：当前处理的命令

3. 工作流程
   - 主线程：监听连接
   - 工作线程：处理客户端命令
     1. 读取命令
     2. 解析协议
     3. 执行操作
     4. 返回结果

4. 线程安全
   - 连接级别：每个连接独立的缓冲区和状态
   - 存储级别：hashtable 的互斥访问
   - 统计级别：原子计数器

5. 性能考虑
   - 适当的线程池大小
   - 合理的缓冲区大小
   - 批量处理命令
   - 减少锁竞争

6. 错误处理
   - 网络错误处理
   - 协议错误处理
   - 资源清理

这种设计相比完全异步的方案有以下优势：
1. 实现简单直观
2. 便于调试和维护
3. 可靠性高
4. 充分复用现有代码

当然，如果后续需要更高的性能，我们也可以考虑迁移到 poly_async 架构，但目前这个方案应该足够满足需求。

## 已完成功能

### 基础架构
- [x] 哈希表实现 (`poly_hashtable`)
- [x] 网络连接管理 (`peer_memkv`)
- [x] 命令处理系统 (`peer_memkv_cmd`)
- [x] 线程池实现
- [x] 并发控制和线程安全
- [x] 统计信息收集

### 基础命令 - 第一阶段
- [x] get - 获取键值
- [x] set - 设置键值
- [x] delete - 删除键值
- [x] stats - 获取统计信息
- [x] version - 获取版本信息
- [x] quit - 关闭连接

### 存储扩展命令 - 第二阶段
- [x] add - 仅当键不存在时添加
- [x] replace - 仅当键存在时替换
- [x] append - 追加数据到现有值
- [x] prepend - 在现有值前添加数据
- [x] cas - 检查并设置

### 功能扩展命令 - 第三阶段
- [x] incr - 递增数值
- [x] decr - 递减数值
- [x] touch - 更新过期时间
- [x] gat - 获取并更新过期时间
- [x] flush_all - 清空所有数据

## 待实现功能

### Meta 命令 - 第四阶段
- [ ] mg (meta get)
  - 支持 flag 系统
  - 支持二进制 key
  - 支持条件获取
  - 支持批量获取

- [ ] ms (meta set)
  - 支持 flag 系统
  - 支持二进制 key
  - 支持条件设置
  - 支持原子操作

- [ ] md (meta delete)
  - 支持 flag 系统
  - 支持条件删除
  - 支持批量删除

- [ ] ma (meta arithmetic)
  - 支持原子计数
  - 支持条件更新
  - 支持初始值设置

- [ ] me (meta debug)
  - 支持内部状态查看
  - 支持统计信息查看
  - 支持性能指标查看

## 代码审查结果

### 潜在优化点
1. 命令处理函数中有重复的锁管理代码，可以考虑抽象成辅助函数
2. 内存管理可以考虑使用内存池来提高性能
3. 错误处理可以更加统一和完善
4. 统计信息的收集可以更加全面

### 已知问题
1. 需要完善过期时间的处理机制
2. 需要添加更多的单元测试
3. 需要增加性能测试
4. 需要完善文档

## 下一步计划
1. 实现 Meta 命令
2. 优化代码结构，减少重复代码
3. 添加更多测试用例
4. 完善文档
5. 进行性能测试和优化

## 最新进展

### 1. Meta 命令实现
- [x] 添加了 Meta 命令的基础结构
  - 定义了 Meta 命令标志位和条件类型
  - 实现了 Meta 命令的解析函数
  - 实现了基本的 Meta 命令处理函数

### 2. 代码重构
- [x] 添加了通用辅助函数
  - `store_with_lock`: 统一的存储操作
  - `get_with_lock`: 统一的获取操作
  - `delete_with_lock`: 统一的删除操作
  - `send_value_response`: 统一的值响应发送
  - `is_numeric_value`: 数值类型检查

### 3. 单元测试
- [x] 创建了测试框架
- [x] 实现了基础命令测试
  - set/get 测试
  - add/replace 测试
  - append/prepend 测试
  - cas 测试
  - incr/decr 测试
  - 过期时间测试

## 下一步建议

### 1. 测试框架完善
- [ ] 参考现有测试代码（如 `test_basic.c`、`test_concurrent.c`），完善测试框架
- [ ] 添加更多的并发测试用例
- [ ] 添加性能基准测试
- [ ] 添加内存泄漏检测

### 2. Meta 命令完善
- [ ] 实现原子操作支持
- [ ] 完善条件操作
- [ ] 添加批量操作优化
- [ ] 添加更多的错误处理

### 3. 性能优化
- [ ] 实现内存池，参考现有的内存管理代码
- [ ] 优化锁策略，减少锁粒度
- [ ] 添加性能监控和统计

### 4. 代码质量提升
- [ ] 统一错误处理和日志格式
- [ ] 添加更多的注释和文档
- [ ] 代码风格统一

## 代码审查结果

### 改进点
1. 锁管理优化
   - [x] 使用辅助函数统一管理锁
   - [x] 减少锁的持有时间
   - [ ] 考虑使用更细粒度的锁

2. 内存管理优化
   - [x] 统一的内存分配和释放流程
   - [ ] 考虑添加内存池
   - [ ] 添加内存使用统计

3. 错误处理改进
   - [x] 统一的错误响应格式
   - [x] 更详细的错误信息
   - [ ] 添加错误日志

4. 性能优化
   - [ ] 批量操作优化
   - [ ] 并发性能优化
   - [ ] 内存分配优化

### 发现的问题

1. 并发安全
   - 需要仔细审查所有的锁使用
   - 可能存在死锁风险
   - 需要添加更多的并发测试

2. 内存管理
   - 可能存在内存泄漏
   - 需要更好的内存使用策略
   - 需要添加内存使用监控

3. 错误处理
   - 部分错误信息不够明确
   - 需要更好的错误恢复机制
   - 需要添加更多的错误测试用例

4. 性能问题
   - 锁竞争可能成为瓶颈
   - 内存分配可能影响性能
   - 需要添加性能测试基准

## 下一步计划

1. 完善 Meta 命令
   - [ ] 实现原子操作支持
   - [ ] 完善条件操作
   - [ ] 添加批量操作优化

2. 性能优化
   - [ ] 实现内存池
   - [ ] 优化锁策略
   - [ ] 添加性能监控和统计

3. 测试完善
   - [ ] 添加并发测试
   - [ ] 添加压力测试
   - [ ] 添加内存泄漏测试

4. 文档完善
   - [ ] 添加详细的 API 文档
   - [ ] 添加性能测试报告
   - [ ] 添加部署指南

## 技术债务

1. 代码质量
   - 部分代码结构可以进一步优化
   - 需要添加更多的注释
   - 需要统一代码风格

2. 测试覆盖
   - 需要提高测试覆盖率
   - 需要添加更多的边界测试
   - 需要添加更多的错误测试

3. 文档
   - 需要更新 API 文档
   - 需要添加更多的示例
   - 需要添加故障排除指南

## 总结

项目已经完成了基本功能的实现，并进行了初步的代码重构和测试添加。下一步将重点关注性能优化、测试完善和文档更新。主要的挑战在于提高系统的并发性能和可靠性，同时保持代码的可维护性。
